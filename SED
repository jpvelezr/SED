using AAAPARLECJSON
#using AAACOMPUTO

    @everywhere function instanceEvents()
        ocu = round(rand(),4)
        dur = round(rand(),4)
        return [ocu dur]
    end

    eventListConfig,matSupEq,lifeCycleTime,confidenceInterval,
        iterations,costNoFlow,VID,VIDstr,configGroupMant,numberEvents,
        numberEquip = LecturaJsonPar()

    LEF = hcat(VID,zeros(numberEvents,2));
    dur = [5;3;6;1;4;3;2;7;5;3;4;2;3;4];              # Cambiar por aleatorios
    # dur = rand(numberEvents,1)
    ocu = [8;4;1;9;2;5;4;1;9;3;4;5;3;5];              # Cambiar por aleatorios
    # ocu = rand(numberEvents,1)
    LEF[:,4] = dur
    LEF[:,5] = ocu

    MoF = eventListConfig[:,11]             # Si es falla (1) o mantenimiento (2)
    VPC = eventListConfig[:,15]
    RelEv = eventListConfig[:,12]

    # LEF[7,4:5] = instanceEvents(LEF[7,3])

    TR = 0
    MEP = []

    # while clock < lifeCycleTime

        id = [LEF[:,1] LEF[:,2] LEF[:,3]]                       # Matriz de ID
        dur = LEF[:,4]                                          # Vector de duraciones
        ocu = LEF[:,5]                                          # Vector de ocurrencias

        prox = find(map(x -> x==minimum(ocu),ocu))              # Encuntra los eventos con próximas ocurrencias
        LEA = LEF[prox,:]                                       # Obtiene la lista de Eventos Actuales

        ocu = float(ocu - LEA[:,5][1])                               # Resta la ocurrencia a los eventos futuros

        for i = 1:size(LEA)[1]
            if MoF[prox][i] == 2                          # Pregunta si el evento es falla o mantenimiento
                inst = RelEv[prox][i]; inst = inst[1]           # Si es mantenimiento, encuentra las fallas asociadas
                pos2reinst = find(map(x -> x==inst,RelEv));     # Encuentra la posición de las fallas relacionadas
                for j = 1:length(pos2reinst)
                     # ocu[pos2reinst[j]] = round(rand(),4)        # Reinstancia las fallas asociadas en LEF
                     ocu[pos2reinst[j]] = instanceEvents()[1]
                     dur[pos2reinst[j]] = instanceEvents()[2]
                end
            end
            #ocu[prox[i]] = round(rand(),4)                      # Reinstancia eventos de LEA en LEF
            ocu[prox[i]] = instanceEvents()[1]
            dur[prox[i]] = instanceEvents()[2]
        end
        LEF[:,5] = ocu
        LEF[:,4] = dur

        haySerie = Array{Any}(size(LEA)[1],1)

        if !isempty(LEA)                            # Pregunta si hay eventos en LEA
            for i = 1:size(LEA)[1]
                if LEA[i,:][1] == 0                 # Recorre LEA y pregunta si hay eventos asociados a equipos serie
                    haySerie[i] = 1                 # Asigna 1 si encuentra eventos asociados a equipos serie
                else
                    haySerie[i] = 0                 # Asigna 0 si encuentra eventos asociados a equipos serie
                end
            end
            if sum(haySerie) != 0
                posSerie = find(map(x -> x==1,haySerie))    # Busca posiciones de LEA en donde hay eventos asociados a equipos serie
                durSeries = LEA[posSerie,:][:,4]                     # Encuentra eventos asociados a equipos serie
                durAlm = maximum(durSeries)                          # Almacena la mayor duración de los eventos serie
                posSerieMayor = find(map(x -> x==durAlm,durSeries))
                SerieMayor = LEA[posSerieMayor,:]                    # Encuentra el evento serie de mayor duración
                id = [SerieMayor[1] SerieMayor[2] SerieMayor[3]]     # ID del evento serie de mayor duración
                Oc = SerieMayor[5]; Du = SerieMayor[4]               # Ocurrencia y Duración del evento serie de mayor duración

                PC = VPC[prox][posSerieMayor];
                TI = TR + Oc;
                TF = TI + Du;                                       # Registro del evento serie en MEP
                TR = TF;
                push!(MEP,[id TI TF PC])
                LEA = LEA[setdiff(1:end, posSerieMayor), :]
                # FuncionSerie
            else
                # FuncionParalelo                 # Asigna 0 si encuentra eventos asociados a equipos serie
            end
        end
    # end
